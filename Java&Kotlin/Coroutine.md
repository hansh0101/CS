# Coroutine

설명에 앞서, 아래 글은 코루틴에 대한 이해를 돕기 위해 구체적인 코드 위주가 아닌 추상적인 개념 위주로 정리하였다고 밝힙니다.

### Coroutine

- 코루틴이란 무엇인가에 대해,
    
    > 1. **협력형 멀티 태스킹**
    2. 동시성 프로그래밍 지원
    3. 비동기 처리를 쉽게 도와줌
    > 
    
    이 3가지 키워드로 알아보려고 한다. 사실 협력형 멀티 태스킹에 대한 내용을 이해한다면 코루틴을 안다고 말할 수 있지만, 완전히 내 것으로 체화하기 위해서는 동시성 프로그래밍과 비동기 처리에 대한 관점에서 이해하는 것도 중요하다.
    

### 협력형 멀티 태스킹

협력형 멀티태스킹을 프로그래밍 언어로 표현하면 `Co + Routine` 이다. `Co` 라는 접두어는 “협력”, “함께” 라는 의미를 지니고 있다. `Routine` 은 하나의 Task, 함수 정도로 생각하면 된다. 즉, 협력하는 함수이다. 먼저 Routine에 대해서 알아보자.

Routine에는 우리가 일반적으로 알고있는 main routine과 sub routine이 존재한다. 이런 단어들이 생소할 수 있지만, 우리가 매일 작성하는 코드에서 그 예시들을 찾을 수 있다.

```java
// Main Routine
public static void main(String[] args) {
	...
	int addedValue = plusOne(10);
	...
}

// Sub Routine
int plusOne(int value) {
	int one = 1;
	int addedValue = value + one;

	return addedValue;
}
```

위의 Java 코드(이후부터는 Kotlin으로 다룰 예정이다.)를 보면, `main` 함수가 말 그대로 Main Routine이다. 즉, 주가 되는 함수인 것이다. 그리고 메인이 되는 함수는 다른 서브 함수, 즉 Sub Routine인 plusOne을 호출한다. 우리가 짜는 프로그램은 대개 이런 형식이라서 어색하지 않을 것이다.

하지만, 이 Sub Routine에서 우리가 눈여겨봐야 할 점이 있다.

![Untitled](Hi,%20Coroutine%20%5BKotlin%5D%20731601929bd34e60bbd00ab25aabc25f/Untitled.png)

Sub Routine은 시작점과 종료점이 명확하다. 즉, Main Routine이 Sub Routine을 호출하면, Sub Routine의 맨 처음 부분에서 시작하여 `return` 문을 만나거나 Sub Routine의 Scope가 닫히는 지점에 도달하면 해당 Sub Routine이 끝나게(탈출하게) 된다.

이번엔 아래 Kotlin 코드를 보겠다.

```kotlin
// Main Routine
fun main() {
	...
	val addedValue = plusOne(value)
	...
}

// Sub Routine
fun plusOne(value: Int) {
	val one = 1
	val addedValue = value + one
	
	return addedValue
}
```

메인 스레드가 `plusOne` 이라는 Sub Routine에 진입한다. 당연히 코드는 처음부터 진입이 되어 Sub Routine의 맨 윗줄부터 실행될 것이고, 아래 코드들을 하나하나 실행해서 `return` 문을 만나면 Sub Routine(Callee)을 호출했던 Main Routine(Caller)의 코드로 탈출한다. 그리고 **진입점과 탈출점 사이에 스레드는 블락되어있다**. 우리가 늘 짜던 코드다.

**하지만 코루틴(Coroutine)은 우리에게 익숙한 이 방식과는 조금 다르게 동작한다.**

![Untitled](Hi,%20Coroutine%20%5BKotlin%5D%20731601929bd34e60bbd00ab25aabc25f/Untitled%201.png)

이게 무슨 해괴망측한 소리인가 싶지만(나도 처음에는 이게 무슨 말인가 싶었다) 코루틴의 동작 방식에 대해서 차근차근 이해해보자.

코루틴도 routine이기 때문에 하나의 함수로 생각해보자. 그런데 코루틴은, 우리가 익숙한 routine의 동작 방식과는 조금 다르게, 이 함수에 진입할 수 있는 진입점도 여러 개이고, 함수를 빠져나갈 수 있는 탈출점도 여러 개이다. 즉, **코루틴 함수는 꼭 `return` 문이나 스코프가 끝나지 않았더라도 언제든지 중간에 나갈 수 있고, 언제든지 다시 나갔던 그 지점으로 들어올 수 있다.**

코드로 알아보자.

```kotlin
/*
1. 스레드의 main 함수가 drawPerson()을 호출하면,
	하나의 코루틴 함수(블럭)가 생성된다.
	drawPerson()은 언제든 진입, 탈출할 수 있는 자격이 주어진다.
*/
fun drawPerson() {
	startCoroutine {
		/*
		2. 코루틴 함수가 실행되는 과정에서 suspend 키워드를 가진 함수를 만나게 되면,
			더이상 아래 코드를 실행하지 않고(멈추고, 즉 suspend)
			코루틴 함수(블럭)을 탈출한다.
		3. 메인 스레드의 다른 코드들이 실행된다.
			그러나 Head는 어디선가 계속 그려지고 있다.
		*/
		drawHead()
		/*
		3. 메인 스레드의 다른 코드들이 실행된다.
			그러나 Head는 어디선가 계속 그려지고 있다.
		4. 다른 코드들이 실행되다가도, drawHead()가 끝나면
			다시 코루틴 함수로 진입해서 아까 멈춘 부분(drawHead())
			아래부터 다시 실행된다.		
		*/
		drawBody()
		drawLegs()
	}
}

suspend fun drawHead() {
	delay(2000)
	...
}

suspend fun drawBody() {
	delay(2000)
	...
}

suspend fun drawLegs() {
	delay(2000)
	...
}
```

`drawPerson()` 이라는 함수가 있다. 이 함수 안에는 `startCoroutine` 이라는 코루틴 빌더가 있다. (**실제로 startCoroutine이라는 빌더는 존재하지 않는데**, 코루틴 빌더는 상황마다 다르게 만들어주기 때문에 여기서는 그냥 **이해하기 쉽게 startCoroutine이라는 코루틴 빌더로 코루틴을 만든다고 친 것**이다. 일단 이해를 먼저 하기 위해서!)

`startCoroutine` 이라는 코루틴을 만나게 되면 해당 함수는 코루틴으로 동작할 수 있다. 따라서, 언제든 함수 실행 중간에 `drawPerson()` 을 나갈 수도, 다시 들어올 수도 있는 자격이 부여되는 것이다. (우리가 기존에 코드를 짜던 방식으로는 상상도 못한 **ㄴㅇㄱ**) 하지만 항상 그렇게 내 마음대로 들락날락 할 수는 없다. 그렇다면 언제 코루틴을 중간에 나갈 수 있을까? 코루틴 함수 내에서 `**suspend`** 로 선언된 함수를 만나면, 잠시 코루틴 밖으로 나갈 수 있다.

> 중간 정리: 위 코드에서는 drawPerson()이 Main Routine, drawHead(), drawBody(), drawLegs()가 Sub Routine에 해당됨
> 

이제 순서를 따라가보자.

1. 스레드의 Main함수가 `drawPerson()` 을 호출하면, `startCoroutine` 블럭을 만나 하나의 코루틴을 만들어 작업을 시작한다. 위에서 말했듯이, 이제 `drawPerson()` 은 진입점과 탈출점이 여러 개가 되는 자격이 주어진 것이다.
2. 코루틴이 작업을 시작했지만, `suspend` 를 만나기 전까지는 우리가 일반적으로 짜오던 코드와 다를 바가 없다. `suspend` 로 정의된 함수가 없다면, 그냥 코루틴 스코프가 끝날 때까지 계속 실행된다. **하지만**, `drawHead()` 는 `suspend` 로 정의된 함수이다. 따라서, `drawHead()` 부분에서 더 이상 아래 코드(`drawBody()`)를 실행하지 않고, `**drawPerson()` 이라는 코루틴 함수를 잠시 탈출한다.**
3. 메인 스레드가 `drawPerson()` 이라는 코루틴에서 탈출했다. 그럼 우리의 메인 스레드는 잠시 휴식을 하고있을까? (~~개미와 베짱이 생각이 나네요~~) 아니다. ~~서버에서도 쓴다고 하지만 나는 서버 개발을 안 해봐서 모르겠다~~ Android라면 메인 스레드가 아마 UI 작업을 하고있을 수도 있다. 그러나 중요한 사실은, `drawHead()` 는 어디선가 계속 수행되고 있다. 우리의 메인 스레드는 `drawPeron()` 에서 코루틴을 만들어 작업을 시작하다가 2초가 걸리는 `suspend` 함수인 `drawHead()` 를 만나 코루틴을 탈출했지만, `**drawHead()` 는 어디선가 계속 수행되고 있다!** `drawHead()` 는 메인 스레드에서 동시성 프로그래밍으로 작동하고 있을수도 있고, 다른 스레드에서 작동하고 있을 수도 있다. 이 `**suspend` 함수가 어떤 스레드 상에서 계속 동작하고 있을지는 프로그래머가 자유롭게 선택할 수 있다.**
4. 그렇게 메인 스레드가 다른 코드들을 실행하다가도 `drawHead()` 가 제 역할을 다 끝내면, 메인 스레드는 아까 탈출했던 `drawPerson()` 에 있는 코루틴으로 돌아간다. 그리고 아까 탈출했던 `drawHead()` 아래에 있는 `drawBody()` 부터 작업을 재개(resume)한다.

위의 4단계 과정에서 본 것처럼, 코루틴 함수는 언제든 들락날락 할 수 있다. 코루틴의 이런 성향은, 동시성 프로그래밍과 아주 밀접한 관계가 있다.

### 동시성 프로그래밍

이 얘기를 하기에 앞서 정리하고 넘어갈 내용이 있다. 내가 맨 처음 코루틴을 접했을 때, 가장 궁금했던 점은 바로 이것이었다. 

> **코루틴이 좋다는 건 알겠는데, 그래서 왜 스레드 하나 만들어서 작업하는 것보다 코루틴을 쓰는 게 더 좋은지 궁금하다 이 말이야**
> 

그래서 정리하고 넘어가기로 했다.

- **병렬성**
    - 다양한 작업을 `실제로` 동시에 실행
- **동시성**
    - 여러 작업을 동시에 실행`되는 것처럼 보이게` 실행
    
    > 한 마디로 정리하면, 
    책상 위에 있는 두 장의 종이에,
    `병렬성` - 왼손으로  글씨쓰면서 오른손으로 그림 그리기
    `동시성` - 오른손으로 왼쪽 종이에 글씨 쓰다가 재빨리 오른쪽 종이로 넘어와서 그림 그리다가 재빨리 왼쪽 종이로 넘어가서 글씨 쓰다가 재빨리 오른쪽 종이로 넘어와서 그림 그리기
    > 

코루틴은 개념 자체만 놓고 보면 병렬성이 아니라 동시성을 지원하는 개념이다. (여담으로 내가 유일하게 가지고 있는 코틀린 서적은 주 내용이 코루틴인데, 그래서 책 제목이 “코틀린 동시성 프로그래밍" 이다. 진짜 한 마디만 덧붙이면 진짜 좋은 책인데 절판되었다. 필요하면 빌려줄까?)

코루틴이 동시성을 지원하는 개념이라는 것을 코드로 살펴보자.

코루틴도 루틴이다. 즉, 스레드가 아니라 일반 서브루틴과 비슷한 루틴이기 때문에 한 스레드에 여러 코루틴이 존재할 수 있다.

위의 코드에서는 메인 스레드에 코루틴이 두 개가 있다. 하나는 왼쪽 종이에 그림을 그리는 코드고 다른 하나는 오른쪽 종이에 그림을 그리는 코드이다. 메인 스레드가 실행되면서 먼저 왼쪽 코루틴인 `drawPersonToPaperA()` 라는 메서드를 만났다고 해보자. 해당 메서드는 가상 코루틴 빌더인 `startCoroutine {}` 블럭으로 인해 코루틴이 되고, 메서드를 중간에 나갔다가 들어올 수 있는 힘을 얻게 된다. `drawPersonToPaperA()` 가 호출되어 `suspend` 함수인 `drawHead()` 를 만나게 되면 이 코루틴을 잠시 빠져나간다.

왼쪽 코루틴을 빠져나갔지만 그렇다고 메인 스레드가 가만히 놀고있지 않는다. 다른 `suspend` 함수들을 찾거나 resume되어지는 다른 코드들을 찾는다. 왼쪽 코루틴의 경우 2초동안 `drawHead()` 작업을 하게된다. 그러나 `delay(2000)` 는 스레드를 블락시키지 않기 때문에, 다른 일들을 할 수 있다. 뿐만 아니라 `drawHead()` 함수 안에서 다른 스레드를 실행시킨다면 병렬적으로도 실행이 가능하다. 왼쪽 코루틴을 빠져나온 스레드가 오른쪽 코루틴을 만나게 되어 또 한 번 `suspend` 함수를 만나게 되면 아까 종이 2장에서의 동시성을 설명한 것과 같은 현상이 일어난다. 아까 오른손으로 왼쪽 종이와 오른쪽 종이를 아주 빠르게 왔다갔다 하면서 글씨를 쓰다가 그림을 그리는 것 같은 셈이다. **이렇게 코루틴을 사용하면 하나의 스레드 안에서 동시성 프로그래밍이 가능하다.**

**코루틴을 생성해서 동시성 프로그래밍을 하는 것은 스레드를 사용해서 동시성 프로그래밍을 하는 것과는 차원이 다른 효율을 제공한다.** 위에서 말한 동작을 스레드 두 개를 만들어 실행한다고 가정하면,

CPU가 1개일 때, 스레드 A와 스레드 B가 번갈아 작업을 하려면(동시성을 만족시키려면), CPU가 매번 스레드를 점유했다가 놓아주어야 한다. 이를 **컨텍스트 스위칭**이라고 하는데, 하나의 스레드에서 단순히 코루틴을 왔다갔다 하는 것과는 다르게 **꽤 비용이 드는 작업**이다.

아래는 ‘함수형 코루틴' 이라는 책에 나오는 구문이라고 한다.

> 2,000개 미만의 스레드에는 1.5GB 이상의 메모리가 필요하다.
1,000,000개의 코루틴은 700MB 미만의 메모리가 필요하다.
결론은 코루틴은 매우 매우 가볍다는 것이다.
> 

### 비동기 프로그래밍

위에서 설명한 코루틴의 능력으로, 비동기 처리가 굉장히 쉬워질 수 있다. 심지어는 이게 비동기 처리인가 싶을 정도로 간결한 코드를 짤 수 있다.

한 가지 예시를 들어보자. 평범한 인턴 승현의 기상부터 출근까지의 과정이다.

1. 7시 기상
2. 샤워하기
3. 옷 입기
4. 지하철 타기
5. 버스 타기
6. 회사 도착하기
7. 일하기

위의 시나리오는 꼭 순서대로 이루어지는 작업이다. 가령, 지하철을 아직 안 탔는데 버스를 먼저 타면 안 되고, 옷을 안 입었는데 지하철을 타러가면 안 되는 것처럼 말이다. 또한 각 과정은 시간이 어느 정도 걸리는 작업이라고 가정하자. 네트워크 처리나 IO 처리처럼 적당히 꽤 걸리는 작업이라고 해보자. 이런 비동기 처리를 코틀린에서는 한 3가지 방법 쯤으로 구현할 수 있다.

**Callback**

가장 먼저 callback을 사용할 수 있다.

```kotlin
fun goCompany(person: Person) {
	val 자는승현 = person

	wakeUp(자는승현) { 비몽사몽한승현 ->
		takeShower(비몽사몽한승현) { 씻은승현 ->
			putOnShirt(씻은승현) { 옷입은승현 ->
				getOnSubway(옷입은승현) { 지하철탄승현 ->
					getOnBus(지하철탄승현) { 버스탄승현 ->
						val 출근한승현 = finish(버스탄승현)
						출근한승현.doWork()
					}
				}
			}
		}
	}
}
```

~~흔히들 `콜백지옥` 이라고도 한다.~~ 콜백으로 비동기 처리를 구현했을 때 흔히 겪는 복잡한 코드이다. 심지어 아직 예외 처리를 단 하나도 하지 않았음에도 코드가 벌써 가독성이 떨어진다. 비동기 처리를 위한 다양한 방법이 나오기 전에는 대부분 이런 식으로 처리했다.

그렇다면 이번에는 비동기 처리에 산소 호흡기를 달아준 RxKotlin으로 짜여진 동일한 코드를 보자.

**RxKotlin**

```kotlin
fun goCompany(person: Person) {
	val 자는승현 = person

	Observable
			.just(person)
			.observeOn(MAIN_Thread)
			.subscribeOn(IO_Thread)
			.flatMap { 자는승현 -> wakeUp(자는승현) }
			.flatMap { 비몽사몽한승현 -> takeShower(비몽사몽한승현) }
			.flatMap { 씻은승현 -> putOnShirt(씻은승현) }
			.flatMap { 옷입은승현 -> getOnSubway(옷입은승현) }
			.flatMap { 지하철탄승현 -> getOnBus(지하철탄승현) }
			.flatMap { 버스탄승현 -> finish(버스탄승현) }
			.subscribe({ 출근한승현 ->
				출근한승현.doWork()
			},{
				// 실패했을 때 예외처리
			})
}
```

콜백 코드보다 가독성이 더 좋은 것 같다. `wakeUp()`, `takeShower()`, `putOnShirt()` 등등의 함수들이 보통 사람이 생각하는 것처럼 순차적으로 보이기 때문이 아닐까? 즉 각 과정의 함수들이 동일한 depth를 유지하며 동기적인 코드처럼 보이기 때문에 훨씬 보기 쉬워졌다.

하지만, Rx는 모르는 사람들도 많다. Rx를 모르는 사람이 이 코드를 보면, `Observable` 이 무엇인지, `just` 가 무엇인지, `flatMap` 은 무엇인지 코드를 보다보면 어지러울 수 있다. 뿐만 아니라 Rx가 제공하는 마법같은 operation이 상당히 많기 때문에 학습 곡선이 꽤 높기로 유명하다.

하지만 Rx를 아는 사람들끼리는 너무나도 좋은 도구인 것은 확실하며, 높은 학습 곡선만큼 효율성도 크다. 아무튼 이렇게 Rx로 비동기 처리를 하는 방법도 있다.

그렇다면 이번에는 우리가 이제 막 이해한 코루틴으로 비동기 처리하는 동일한 코드를 보자.

**Kotlin + Coroutine**

```kotlin
suspend goCompany(person: Person) {
	val 자는승현 = person

	try {
		val 비몽사몽한승현 = wakeUp(자는승현)
		val 씻은승현 = takeShower(비몽사몽한승현)
		val 옷입은승현 = putOnShirt(씻은승현)
		val 지하철탄승현 = getOnSubway(옷입은승현)
		val 버스탄승현 = getOnBus(지하철탄승현)
		val 출근한승현 = finish(버스탄승현)
		출근한승현.doWokrk()
	} catch (e: Exception) {
		// 실패했을 때 예외처리
	}
}
```

“이게 비동기 처리를 하는 코드라고?”라는 생각이 들 수도 있다. 그러나 분명히 비동기 코드다! 안에서 호출되는 각 함수들은 분명히 네트워크를 타고 실행돼야하는 오래걸리는 작업이고, 언제 끝날지 모르는 비동기 작업들이지만 각자 함수들의 순서는 정확히 지켜진다. `takeShower()` 함수는 `wakeUp()` 함수가 끝나야만 실행되고, `putOnShirt()` 함수는 `takeShower()` 함수가 끝나야만 실행된다.

이게 가능한 이유는, `goCompany` 라는 함수가 코루틴이기에 `wakeUp` 을 만나면 `wakeUp` 함수를 실행함과 동시에(여기서는 백그라운드 스레드에서 동시에 실행될 것이다.) 잠시 `goCompay` 를 빠져나간다. 그러다가 `wakeUp` 이 자신의 일을 끝마치면 다시 `goCompany` 로 돌아올 수 있기 때문이다. 이게 코루틴으로 비동기 처리를 할 때 생기는 장점이다.

# 끝